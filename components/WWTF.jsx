import * as THREE from "three";
import { useMemo, useContext, createContext, useRef } from "react";
import { useFrame, extend } from "@react-three/fiber";
import {
  useGLTF,
  Merged,
  RenderTexture,
  PerspectiveCamera,
  Text,
} from "@react-three/drei";
THREE.ColorManagement.legacyMode = false;

/*
The following was auto-generated by: npx gltfjsx computers.glb --transform --instance
By using the --instance flag it detects similar geometry and instances it, thereby minimizing draw-calls

Author: Rafael Rodrigues (https://sketchfab.com/RafaelBR873D)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/old-computers-7bb6e720499a467b8e0427451d180063
Title: Old Computers
*/

const context = createContext();
export function Instances({ children, ...props }) {
  const { nodes } = useGLTF("/computers_1-transformed.glb");
  const instances = useMemo(
    () => ({
      Object: nodes.Object_4,
      Object1: nodes.Object_16,
      Object3: nodes.Object_52,
      Object13: nodes.Object_172,
      Object14: nodes.Object_174,
      Object23: nodes.Object_22,
      Object24: nodes.Object_26,
      Object32: nodes.Object_178,
      Object36: nodes.Object_28,
      Object45: nodes.Object_206,
      Object46: nodes.Object_207,
      Object47: nodes.Object_215,
      Object48: nodes.Object_216,
      Sphere: nodes.Sphere,
    }),
    [nodes]
  );
  return (
    <Merged castShadow receiveShadow meshes={instances} {...props}>
      {(instances) => (
        <context.Provider value={instances}>{children}</context.Provider>
      )}
    </Merged>
  );
}

export function Screen(props) {
  const instances = useContext(context);
  return (
    <group {...props} dispose={null}>
      <ScreenText invert position={[0, 1, -4.64]} rotation={[0, 0, 0]} />

      <Leds instances={instances} />
    </group>
  );
}

/* This component renders a monitor (taken out of the gltf model)
   It renders a custom scene into a texture and projects it onto monitors screen */
function Frame({ frame, panel, children, ...props }) {
  return (
    <group {...props}>
      <mesh>
        <boxGeometry args={[20, 19, 0.1]} />
        <meshBasicMaterial toneMapped={false}>
          <RenderTexture width={512} height={512} attach="map" anisotropy={16}>
            {children}
          </RenderTexture>
        </meshBasicMaterial>
      </mesh>
    </group>
  );
}

/* Renders a monitor with some text */
function ScreenText({ invert, x = 0, y = -4, ...props }) {
  const ref = useRef();

  function easeOutCubic(x) {
    return 1 - Math.pow(1 - x, 3);
  }

  useFrame((state) => {
    const time = state.clock.elapsedTime;

    const delay = 0.2;
    const duration = 4;
    const percentage = easeOutCubic((time - delay) / duration);

    if (time - delay <= duration) {
      ref.current.position.y = y + percentage * Math.abs(y);
    }

    // move to center after delay
    const riseDelay = 4;
    const riseDuration = 2;
    const risePercentage = easeOutCubic((time - riseDelay) / riseDuration);
    if (time > riseDelay && time - riseDelay <= riseDuration) {
      ref.current.position.y = risePercentage * 2.7;
      ref.current.material.opacity = 1 - risePercentage * 0.9;
    }
  });

  return (
    <Frame {...props}>
      <PerspectiveCamera
        makeDefault
        manual
        aspect={1 / 1}
        position={[0, 0, 25]}
      />
      <color attach="background" args={[invert ? "black" : "white"]} />
      <ambientLight intensity={0.5} />
      <directionalLight position={[10, 10, 5]} />
      <Text
        position={[x, y, 0]}
        ref={ref}
        fontSize={4}
        letterSpacing={-0.05}
        color={!invert ? "black" : "white"}
      >
        WWTF23
      </Text>
    </Frame>
  );
}

// Renders flashing LED's
function Leds({ instances }) {
  const ref = useRef();
  const { nodes } = useGLTF("/computers_1-transformed.glb");
  useMemo(() => {
    nodes.Sphere.material = new THREE.MeshBasicMaterial();
    nodes.Sphere.material.toneMapped = false;
  }, []);

  useFrame((state) => {
    ref.current.children.forEach((instance) => {
      const rand = Math.abs(2 + instance.position.x);
      const t = Math.round(
        (1 + Math.sin(rand * 10000 + state.clock.elapsedTime * rand)) / 2
      );
      instance.color.setRGB(t, t * 1.1, t);
    });
  });

  return (
    <group ref={ref}>
      <instances.Sphere
        position={[-0.41, 1.1, -2.21]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[0.59, 1.32, -2.22]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[1.77, 1.91, -1.17]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[2.44, 1.1, -0.79]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[4.87, 3.8, -0.1]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[1.93, 3.8, -3.69]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[-2.35, 3.8, -3.48]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[-4.71, 4.59, -1.81]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[-3.03, 2.85, 1.19]}
        scale={0.005}
        color={[1, 2, 1]}
      />
      <instances.Sphere
        position={[-1.21, 1.73, -1.49]}
        scale={0.005}
        color={[1, 2, 1]}
      />
    </group>
  );
}
